# convex-hull
Implementation of convex-hull algorithm

## Notes (delete later)
n - размер входных данных  
k - размер оболочки

### Gift wrapping algorithm (Алгоритм Джарвиса)
Ищем против часовой стрелки, начиная с определенной точки

Описание:
1. Возьмем точку p_0 нашего множества с самой маленькой y-координатой (если таких несколько, берем самую правую из них). Добавляем ее в ответ.

2. На каждом следующем шаге для последнего добавленного p_i ищем p_{i+1} среди всех недобавленных точек и p_0 с макисмальным полярным углом относительно p_{i} (если углы равны, надо сравнивать по расстоянию). Добавляем p_{i+1} в ответ. Если p_{i+1} == p_{0} заканчиваем алгоритм.

#### pseudo:
```C
Jarvis(S)
    find i such that S[i] has the lowest y-coordinate and highest x - coordinate
    p0 = S[i]
    pi = p0
    k = 0
    do
        k++
        for (i = k..n)
            if (S[i] has lower angle 
                    and higher distance than S[k] in relation to pi) // comparator
                swap(S[i], S[k])
        pi = S[k]
    while pi != p0
    return k
```
Берем массив точек, выбираем точку с наименьшей y коордой, очев она принадлежит оболочке.  

Дальше эта штука работает фактически как selection sort с компаратором, который выбирает на позицию k лучшую точку относительно текущей pi. После того как выбрали лучшую точку на позцицю k, двигаем k на один, а текущая точка pi становится равна S[K], далее мы для этой точки снова ищем лучшую и.т.д.  

Когда контур замыкается (pi == p0), то k показывает количество точек в принадлежащих контуру облочки. А первые k элементов в исходном массиве S - точки контура.

Добавление каждой точки в ответ занимает O(n) времени, всего k точек в ответе, значит сложность O(nk).
В худшем случае оболочка состоит из всех точек - O(n^2).

## Build
* For graphics install sfml - `sudo apt install libsfml-dev`
